# g正则表达式study1

## 各符号的意义

\d代表任意数字，就是阿拉伯数字 0-9 这些玩意。

`\D`大写的就是和小写的唱反调，\d 你代表的是任意数字是吧？那么我 \D 就代表不是数字的。

`\w`代表字母，数字，下划线。也就是 a-z、A-Z、0-9、_。

\W跟 \w 唱反调，代表不是字母，不是数字，不是下划线的。

\n代表一个换行。

`\r`代表一个回车。

`\f`代表换页。

`\t`代表一个 Tab 。

\s代表所有的空白字符，也就是上面这个：\n、\r、\t、\f。`

\S跟 \s 唱反调，代表所有不是空白的字符。

`\A`代表字符串的开始。

`\Z`代表字符串的结束。

^匹配字符串开始的位置。

$匹配字符创结束的位置。

.代表所有的单个字符，除了 \n \r

[...]`代表在 [] 范围内的字符，比如 [a-z] 就代表 a到z的字母

[^...]`跟 [...] 唱反调，代表不在 [] 范围内的字符

{n}匹配在 {n} 前面的东西，比如: o{2} 不能匹配 Bob 中的 o ，但是能匹配 food 中的两个o。

`{n,m}`匹配在 {n,m} 前面的东西，比如：o{1,3} 将匹配“fooooood”中的前三个o。

`{n，}`匹配在 {n,} 前面的东西，比如：o{2,} 不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。

`*`和 {0,} 一个样，匹配 * 前面的 0 次或多次。 比如 zo* 能匹配“z”、“zo”以及“zoo”。

`+`和{1，} 一个样，匹配 + 前面 1 次或多次。 比如 zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。

`？`和{0,1} 一个样，匹配 ？前面 0 次或 1 次。

ok



知道了这些之后



我们怎么用 python 来进行判断呢？



那就要使用到 python 的库了



它就是



**re**



接下来我们就来使用 re 模块



对其常用的方法



来使用正则表达式



**re.match**



使用这个方法



主要传入两个参数



第一个就是我们的匹配规则



第二个就是需要被过滤的内容



例如



我们想要从这



```text
Xiaoshuaib has 100 bananas
```



拿到一个数字



那么我们就可以这样



```text
import re
content = 'Xiaoshuaib has 100 bananas'
res = re.match('^Xi.*(\d+)\s.*s$',content)
print(res.group(1))
```



通过我们刚刚说的匹配符号



可以定义出相应的匹配规则



在这里我们将我们需要的目标内容用 () 括起来



此刻我们获得结果是



0



那么如果我们想要 100 这个数字呢？



可以这样



```text
import re

content = 'Xiaoshuaib has 100 bananas'
res = re.match('^Xi.*?(\d+)\s.*s$',content)
print(res.group(1))
```



看出区别了么



第二段代码我们多了一个 ？符号



在这里呢



涉及到两个概念



一个是



贪婪匹配



另一个是



非贪婪匹配



所谓贪婪匹配



就是我们的第一段代码



一个数一个数都要去匹配



而非贪婪呢



我们是直接把 100 给匹配出来了





![img](https://pic2.zhimg.com/80/v2-ab346284f8e27891874ef4b284be3585_720w.jpg)







刚刚我们用到的



.\*？



是我们在匹配过程中最常使用到的



表示的就是匹配任意字符



但是



.*？的 . 代表所有的单个字符，除了 \n \r



如果我们的字符串有换行了



怎么办呢？



比如这样



```text
content = """Xiaoshuaib has 100 
bananas"""
```



那么我们就需要用到 re 的匹配模式了



说来也简单



直接用 re.S 就可以了



```text
import re

content = """Xiaoshuaib has 100 
bananas"""
res = re.match('^Xi.*?(\d+)\s.*s$',content,re.S)
print(res.group(1))
```



可能有些朋友会觉得



匹配一个东西还要写开头结尾



有点麻烦



那么就可以使用 re 的另一个方法了





**re.search**





它会直接去扫描字符串



然后把匹配成功的**第一个**结果的返回给你



```text
import re

content = """Xiaoshuaib has 100 
bananas"""
res = re.search('Xi.*?(\d+)\s.*s',content,re.S)
print(res.group(1))
```



这样子也是可以获取 100 的



但是如果我们的内容是这样的



```text
content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
```



想要获取**所有**的 100 呢？



这时候就要用到 re 的另一个方法了





**re.findall**



通过它我们就能轻松的获取所有匹配的内容了



```text
import re

content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
res = re.findall('Xi.*?(\d+)\s.*?s;',content,re.S)
print(res)
```



这里的结果是



['100', '100', '100', '100']





![img](https://pic1.zhimg.com/80/v2-cafece2e64b19ed0282c30a68c9efda4_720w.jpg)





又有朋友觉得



如果我们想直接替换匹配的内容呢



就比如刚刚的字符串



可不可以把 100 直接替换成 250 呢？





![img](https://pic1.zhimg.com/80/v2-295e2d1f5ddc7699e00a0a38f9fe3b00_720w.jpg)





那就要用到 re 的另一个方法了





**re.sub**





可以这样



```text
import re

content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
content = re.sub('\d+','250',content)
print(content)
```



那么结果就变成了



Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;



250 个香蕉



吃....得完么？？





![img](https://pic3.zhimg.com/80/v2-8d467b1adcbfdff35013bd6244f160c2_720w.jpg)







再来说说 re 的另一个常用到的方法吧





**re.compile**





这个主要就是把我们的匹配符封装一下



```text
import re

content = "Xiaoshuaib has 100 bananas"
pattern = re.compile('Xi.*?(\d+)\s.*s',re.S)
res = re.match(pattern,content)

print(res.group(1))
```





其实和我们之前写的一样的



```text
res = re.match('^Xi.*?(\d+)\s.*s$',content,re.S)
```



只不过 compile 一下



便于以后复用



好了



关于 re 模块和正则表达式就介绍完啦





知道了怎么请求数据



也知道了将返回的数据如何正则过滤



那么



爬虫对我们来说还难么？





![img](https://pic2.zhimg.com/80/v2-29519e82c5c4daeadbe7dc6f814d1121_720w.jpg)





这次本篇真的完啦

# 正则表达式study2

这一篇就够了！

[![慕课网](https://pic3.zhimg.com/v2-1a7e8b36a7dc94b127c6cea1773ed171_xs.jpg)](https://www.zhihu.com/org/mu-ke-wang-14)

[慕课网](https://www.zhihu.com/org/mu-ke-wang-14)[](https://www.zhihu.com/question/48510028)

已认证的官方帐号

394 人赞同了该文章

之前我们讲解了 [正则表达式语法](https://link.zhihu.com/?target=https%3A//www.imooc.com/article/300848) 的起源、发展、流派、语法、引擎、优化等相关知识，今天我们主要来学习一下 **正则表达式在 Python语言 中的应用**！

大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。

![img](https://pic4.zhimg.com/80/v2-389b0da89802d2111ba61e78b564f03f_720w.jpg)

## re模块结构


re模块主要定义了9个常量、12个函数、1个异常，每个常量和函数猪哥都会通过实际代码案例讲解，让大家能更直观的了解其作用！

注：为避免出现代码格式错乱，猪哥尽量使用代码截图演示哦。

### 一、re模块简介

聊到Python正则表达式的支持，首先肯定会想到`re`库，这是一个Python处理文本的**标准库**。

**标准库**的意思表示这是一个**Python内置模块**，不需要额外下载，目前Python内置模块大概有300个。可以在这里查看Python所有的内置模块：[https://docs.python.org/3/py-modindex.html#cap-r](https://link.zhihu.com/?target=https%3A//docs.python.org/3/py-modindex.html%23cap-r)

因为re是内置模块，所以不需要再下载，使用时直接引入即可：

import re

re模块官方文档：[https://docs.python.org/zh-cn/3.8/library/re.html](https://link.zhihu.com/?target=https%3A//docs.python.org/zh-cn/3.8/library/re.html)
re模块库源码：[https://github.com/python/cpython/blob/3.8/Lib/re.py

![v2-c022af882c868bde000896bc3271f6e6_720w](D:\gitnote\typora\pic\v2-c022af882c868bde000896bc3271f6e6_720w.jpg)

### 二、re模块常量

re.IGNORECASE 或简写为 re.I

re.ASCII 或简写为 re.A

re.DOTALL 或简写为 re.S

re.MULTILINE 或简写为 re.M 

re.VERBOSE 或简写为 re.X

re.LOCALE 或简写为 re.L

re.UNICODE 或简写为 re.U

re.DEBUG

re.TEMPLATE 或简写为 re.T

*常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 `|` 符号，请勿使用`+` 符号！*

常量即表示不可更改的变量，一般用于做标记。

re模块中有9个常量，常量的值都是int类型！

![img](https://pic4.zhimg.com/80/v2-192d31a9de5470456c61e96d9a9d1aab_720w.jpg)


上图我们可以看到，所有的常量都是在**RegexFlag枚举类**来实现，这是在Python 3.6做的改版。在Python 3.6以前版本是直接将常量写在re.py中，使用枚举的好处就是方便管理和使用！

![img](https://pic2.zhimg.com/80/v2-d442174c6eb02902f5d3e209b9939dc1_720w.jpg)



下面我们来快速学习这些常量的作用及如何使用他们，按常用度排序！

\1. IGNORECASE

**语法：** re.IGNORECASE 或简写为 re.I

**作用：** 进行忽略大小写匹配。

**代码案例：**

![img](https://pic1.zhimg.com/80/v2-6f44888e6114a98b2202a92a8adb7d5c_720w.jpg)


在默认匹配模式下**大写字母B**无法匹配**小写字母b**，而在 忽略大小写 模式下是可以的。

\2. ASCII

**语法：** re.ASCII 或简写为 re.A

**作用：** 顾名思义，ASCII表示ASCII码的意思，让 `\w`, `\W`, `\b`, `\B`, `\d`, `\D`, `\s` 和 `\S` 只匹配ASCII，而不是Unicode。

**代码案例：**

![img](https://pic3.zhimg.com/80/v2-1a6b313162711f831dc781303e32f172_720w.jpg)


在默认匹配模式下`\w+`匹配到了所有字符串，而在**ASCII**模式下，只匹配到了a、b、c（ASCII编码支持的字符）。

注意：这只对字符串匹配模式有效，对字节匹配模式无效。

\3. DOTALL

**语法：** re.DOTALL 或简写为 re.S

**作用：** DOT表示`.`，ALL表示所有，连起来就是`.`匹配所有，包括换行符`\n`。**默认模式下`.`是不能匹配行符`\n`的**。

**代码案例：**

![img](https://pic4.zhimg.com/80/v2-b4ba1028a21217a29497952101c8947b_720w.jpg)


在默认匹配模式下`.`并没有匹配换行符`\n`，而是将字符串分开匹配；而在**re.DOTALL**模式下，换行符`\n`与字符串一起被匹配到。

注意：**默认匹配模式下`.`并不会匹配换行符`\n`**。

\4. MULTILINE

**语法：** re.MULTILINE 或简写为 re.M

**作用：** 多行模式，当某字符串中有换行符`\n`，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。

**代码案例：**

![img](https://pic4.zhimg.com/80/v2-67991439abbbb34c38b239af08793bbf_720w.jpg)


正则表达式中`^`表示匹配行的开头，默认模式下它只能匹配字符串的开头；而在多行模式下，它还可以匹配 换行符`\n`后面的字符。

注意：正则语法中`^`匹配行开头、`\A`匹配字符串开头，单行模式下它两效果一致，多行模式下`\A`不能识别`\n`。

\5. VERBOSE

**语法：** re.VERBOSE 或简写为 re.X

**作用：** 详细模式，可以在正则表达式中加注解！

**代码案例：**

![img](https://pic1.zhimg.com/80/v2-cfe888f6f0db818d416e343ff51beb08_720w.jpg)


默认模式下并不能识别正则表达式中的注释，而详细模式是可以识别的。

当一个正则表达式十分复杂的时候，详细模式或许能为你提供另一种注释方式，但它不应该成为炫技的手段，建议谨慎考虑后使用！

6.LOCALE

**语法：** re.LOCALE 或简写为 re.L

**作用：** 由当前语言区域决定 `\w`, `\W`, `\b`, `\B` 和大小写敏感匹配，这个标记只能对byte样式有效。**这个标记官方已经不推荐使用**，因为语言区域机制很不可靠，它一次只能处理一个 "习惯”，而且只对8位字节有效。

**注意：** 由于这个标记官方已经不推荐使用，而且猪哥也没使用过，所以就不给出实际的案例！

7.UNICODE

**语法：** re.UNICODE 或简写为 re.U

**作用：** 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。

\8. DEBUG

**语法：** re.DEBUG

**作用：** 显示编译时的debug信息。

**代码案例：**

![img](https://pic2.zhimg.com/80/v2-b4eeb795e2a9480935d4fe5233632615_720w.jpg)



虽然debug模式下确实会打印编译信息，但猪哥并不理解这是什么语言 以及表达的含义，**希望了解的朋友能不吝赐教。**

9.TEMPLATE

**语法：** re.TEMPLATE 或简写为 re.T

**作用：** 猪哥也没搞懂TEMPLATE的具体用处，源码注释中写着：disable backtracking(禁用回溯)，有了解的同学可以留言告知！

![img](https://pic3.zhimg.com/80/v2-2177dfe09c9b6d797a1882c322e976c2_720w.jpg)



\10. 常量总结



1. 9个常量中，前5个（IGNORECASE、ASCII、DOTALL、MULTILINE、VERBOSE）有用处，两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。
2. 常量在re常用函数中都可以使用，查看源码可得知。

![img](https://pic3.zhimg.com/80/v2-0eb3458cd7289709bb70add59efcd962_720w.jpg)



1. 常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 `|` 符号，请勿使用`+` 符号！

![img](https://pic3.zhimg.com/80/v2-6656131dde9861872b16e4cf6be1c43e_720w.jpg)





最后来一张思维导图总结一下re模块中的常量吧，**需要高清图或者xmind文件的同学可在「裸睡的猪」后台回复：re** 获取。

![img](https://pic4.zhimg.com/80/v2-8739802053ac450de80b35f6bcf90acb_720w.jpg)



### 三、re模块函数

re模块有12个函数，猪哥将以功能分类来讲解；这样更具有比较性，同时也方便记忆。

1.查找一个匹配项

查找并返回一个匹配项的函数有3个：**search、match、fullmatch**，他们的区别分别是：



1. **search：** 查找任意位置的匹配项
2. **match：** 必须从字符串开头匹配
3. **fullmatch：** 整个字符串与正则完全匹配



我们再来根据实际的代码案例比较：

**案例1:**

![img](https://pic1.zhimg.com/80/v2-df4c23c93f5ca9ffe242f4a60a44ee1c_720w.jpg)


案例1中**search函数**是在字符串中任意位置匹配，只要有符合正则表达式的字符串就匹配成功，其实有两个匹配项，但search函数值返回一个。

而**match函数**是要从头开始匹配，而字符串开头多了个字母`a`，所以无法匹配，**fullmatch函数**需要完全相同，故也不匹配！

**案例2:**

![img](https://pic4.zhimg.com/80/v2-3394c33c6ad529715f67e9171f5f1bef_720w.jpg)


案例2删除了text最开头的字母a，这样**match函数**就可以匹配啦，而**fullmatch函数**依然不能完全匹配！

**案例3:**

![img](https://pic1.zhimg.com/80/v2-c5e5ffe0b2c59d20a5dd45c317ecac9c_720w.jpg)


案例3中，我们只留下一段文字，并且与正则表达式一致；这时**fullmatch函数**终于可以匹配了。

**完整案例：**

![img](https://pic1.zhimg.com/80/v2-c2b0edb78cc7f3042c429841ced987bc_720w.jpg)

**注意：查找 一个匹配项 返回的都是一个匹配对象（Match）。**

2.查找多个匹配项

讲完查找一项，现在来看看查找多项吧，查找多项函数主要有：**findall函数** 与 **finditer函数**：



1. **findall：** 从字符串任意位置查找，**返回一个列表**
2. **finditer**：从字符串任意位置查找，**返回一个迭代器**



两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。



![img](https://pic1.zhimg.com/80/v2-4c2d71ce1088c2637266ab35a50c86c4_720w.jpg)


如果可能存在大量的匹配项的话，建议使用**finditer函数**，一般情况使用**findall函数**基本没啥影响。

3.分割

**re.split(pattern, string, maxsplit=0, flags=0)** 函数：用 **pattern** 分开 string ， **maxsplit**表示最多进行分割次数， **flags**表示模式，就是上面我们讲解的常量！



![img](https://pic4.zhimg.com/80/v2-c08fa8e4a6a445a37e36761ea0a79d27_720w.jpg)


**注意：`str`模块也有一个 split函数 ，那这两个函数该怎么选呢？**
str.split函数功能简单，不支持正则分割，而re.split支持正则。

**关于二者的速度如何？** 猪哥实际测试一下，在相同数据量的情况下使用`re.split`函数与`str.split`函数**执行次数** 与 **执行时间** 对比图：

![img](https://pic4.zhimg.com/80/v2-a0dfb7664a05c07f7b81d12702b0c52f_720w.jpg)


通过上图对比发现，1000次循环以内`str.split`函数更快，而循环次数1000次以上后`re.split`函数明显更快，而且次数越多差距越大！

**所以结论是：在 不需要正则支持 且 数据量和数次不多 的情况下使用`str.split`函数更合适，反之则使用`re.split`函数。**

注：具体执行时间与测试数据有关！

4.替换

替换主要有**sub函数** 与 **subn函数**，他们功能类似！

先来看看**sub函数**的用法：

**re.sub(pattern, repl, string, count=0, flags=0)** 函数参数讲解：repl替换掉string中被pattern匹配的字符， count表示最大替换次数，flags表示正则表达式的常量。

值得注意的是：**sub函数**中的入参：**repl替换内容既可以是字符串，也可以是一个函数哦！** 如果repl为函数时，只能有一个入参：Match匹配对象。



![img](https://pic4.zhimg.com/80/v2-acb374226ed45d39a4a7ba1e0d50712f_720w.jpg)



**re.subn(pattern, repl, string, count=0, flags=0)** 函数与 **re.sub函数** 功能一致，只不过返回一个元组 (字符串, 替换次数)。

![img](https://pic3.zhimg.com/80/v2-b057eee5f88e4427c78df37d74501bc2_720w.jpg)



5.编译正则对象

**compile函数** 与 **template函数** 将正则表达式的样式编译为一个 正则表达式对象 （正则对象Pattern），这个对象与re模块有同样的正则函数（后面我们会讲解Pattern正则对象）。

![img](https://pic4.zhimg.com/80/v2-ef6e89e8b83012863bca4b4a200bc7fb_720w.jpg)


而**template函数** 与 **compile函数** 类似，只不过是增加了我们之前说的**re.TEMPLATE** 模式，我们可以看看源码。

![img](https://pic4.zhimg.com/80/v2-b05daad758fc2a39ab3b87004d022887_720w.jpg)



6.其他

**re.escape(pattern)** 可以转义正则表达式中具有特殊含义的字符，比如：`.` 或者 `*` ，举个实际的案例：

![img](https://pic1.zhimg.com/80/v2-903a19ca6560faa5ff97e09b16e59390_720w.jpg)

**re.escape(pattern)** 看似非常好用省去了我们自己加转义，但是使用它很容易出现转义错误的问题，所以并不建议使用它转义，**而建议大家自己手动转义！**

**re.purge()** 函数作用就是清除 **正则表达式缓存**，具体有什么缓存呢？我们来看看源码就知道它背地里干了 什么：

![img](https://pic1.zhimg.com/80/v2-17371b6785ee8112fdfdfab08826c694_720w.jpg)


看方法大概是清除缓存吧，我们再来看看具体的案例：

![img](https://pic1.zhimg.com/80/v2-faa3ba56f8137d908f269b044248cf00_720w.jpg)


猪哥在两个案例之间使用了**re.purge()** 函数清除缓存，然后分别比较前后案例源码里面的缓存，看看是否有变化！

![img](https://pic3.zhimg.com/80/v2-161cac2bd5c2f5f2e42f7759b2cae632_720w.jpg)



7.总结

同样最后来一张思维导图总结一下re模块中的函数吧，**需要高清图或者xmind文件的同学可在微信公众号「裸睡的猪」后台回复：re** 获取。

![img](https://pic3.zhimg.com/80/v2-c022af882c868bde000896bc3271f6e6_720w.jpg)



### 四、re模块异常

re模块还包含了一个正则表达式的编译错误，当我们给出的**正则表达式是一个无效的表达式**（就是表达式本身有问题）时，就会raise一个异常！

我们来看看具体的案例吧：

![img](https://pic2.zhimg.com/80/v2-857ad9feebc68f088f573af472569155_720w.jpg)


上图案例中我们可以看到，在编写正则表达式中我们多写了一个括号，这导致执行结果报错；而且是在其他所有案例执行之前，所以说明是在正则表达式编译时期就报错了。

注意：这个异常一定是 正则表达式 本身是无效的，与要匹配的字符串无关！

### 五、正则对象Pattern

关于`re`模块的常量、函数、异常我们都讲解完毕，但是完全有必要再讲讲**正则对象Pattern**。

\1. 与re模块 函数一致

在`re`模块的函数中有一个重要的函数 **compile函数** ，这个函数可以预编译返回一个正则对象，此正则对象拥有与`re`模块相同的函数，我们来看看**Pattern类**的源码。

![img](https://pic1.zhimg.com/80/v2-6ae609e027806c511f578a24d623412c_720w.jpg)


既然是一致的，那到底该用**re模块** 还是 **正则对象Pattern** ？

而且，有些同学可能看过`re`模块的源码，你会发现其实**compile函数** 与 其他 **re函数**（search、split、sub等等） 内部调用的是同一个函数，最终还是调用正则对象的函数！

![img](https://pic1.zhimg.com/80/v2-793ac58ceff4191cb328869cb2a69ca4_720w.jpg)


也就是说下面 两种代码写法 底层实现 其实是一致的：

\# re函数 re.search(pattern, text) # 正则对象函数 compile = re.compile(pattern) compile.search(text)

那还有必要使用**compile函数** 得到正则对象再去调用 **search函数** 吗？直接调用re.search 是不是就可以？

\2. 官方文档怎么说

关于到底该用**re模块** 还是 **正则对象Pattern** ，官方文档是否有说明呢？



![img](https://pic1.zhimg.com/80/v2-5ba334ea73634a5d608c36ce752a5cf4_720w.jpg)


官方文档推荐：**在多次使用某个正则表达式时推荐使用正则对象Pattern** 以增加复用性，因为通过 **re.compile(pattern)** 编译后的模块级函数会被缓存！

\3. 实际测试又如何？

上面官方文档推荐我们在 **多次使用某个正则表达式时使用正则对象**，那实际情况真的是这样的吗？

我们在实测一下吧



![img](https://pic2.zhimg.com/80/v2-ed971d8cf18adf225f558bf45371ff45_720w.jpg)


猪哥编写了两个函数，一个使用**re.search函数** 另一个使用 **compile.search函数** ，分别(不同时)循环执行**count次**(count从1-1万)，比较两者的耗时！

得出的结果猪哥绘制成折线图：

![img](https://pic1.zhimg.com/80/v2-53f9618228c6509bd5235e939c2c523c_720w.jpg)


得出的结论是：100次循环以内两者的速度基本一致，当超出100次后，使用 **正则对象Pattern** 的函数 耗时明显更短，所以比**re模块** 要快！

通过实际测试得知：Python 官方文档推荐 **多次使用某个正则表达式时使用正则对象函数** 基本属实！

### 六、注意事项

Python 正则表达式知识基本讲解完毕，最后稍微给大家提一提需要注意的点。

1.字节串 与 字符串

模式和被搜索的字符串既可以是 Unicode 字符串 (str) ，也可以是8位字节串 (bytes)。 但是，Unicode 字符串与8位字节串不能混用！

2.r 的作用

正则表达式使用反斜杠（’’）来表示特殊形式，或者把特殊字符转义成普通字符。

而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。

解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 ‘r’ 前缀的字符串字面值中，反斜杠不必做任何特殊处理。

3.正则查找函数 返回匹配对象

查找一个匹配项（search、match、fullmatch）的函数返回值都是一个 **匹配对象Match** ，需要通过**match.group()** 获取匹配值，这个很容易忘记。

![img](https://pic4.zhimg.com/80/v2-5c3e53c27fcd5f643edd80d29410519f_720w.jpg)


另外还需要注意：**match.group()** 与**match.groups()** 函数的差别！

4.重复使用某个正则

如果要重复使用某个正则表达式，推荐先使用 **re.compile(pattern)函数** 返回一个正则对象，然后复用这个正则对象，这样会更快！

5.Python 正则面试

笔试可能会遇到需要使用Python正则表达式，不过不会太难的，大家只要记住那几个方法的区别，会正确使用，基本问题不大。

# Git命令大全

（查看、添加、提交、删除、找回，重置修改文件）

```
git help <command> # 显示command的help  

git show # 显示某次提交的内容 git show $id  

git co -- <file> # 抛弃工作区修改  

git co . # 抛弃工作区修改  

git add <file> # 将工作文件修改提交到本地暂存区  

git add . # 将所有修改过的工作文件提交暂存区  

git rm <file> # 从版本库中删除文件  

git rm <file> --cached # 从版本库中删除文件，但不删除文件  

git reset <file> # 从暂存区恢复到工作文件  

git reset -- . # 从暂存区恢复到工作文件  

git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  

git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am "some comments"  

git ci --amend # 修改最后一次提交记录  

git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象  

git revert HEAD # 恢复最后一次提交的状态  
```

 

**查看文件diff**

```
git help <command> # 显示command的help  

git show # 显示某次提交的内容 git show $id  

git co -- <file> # 抛弃工作区修改  

git co . # 抛弃工作区修改  

git add <file> # 将工作文件修改提交到本地暂存区  

git add . # 将所有修改过的工作文件提交暂存区  

git rm <file> # 从版本库中删除文件  

git rm <file> --cached # 从版本库中删除文件，但不删除文件  

git reset <file> # 从暂存区恢复到工作文件  

git reset -- . # 从暂存区恢复到工作文件  

git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  

git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am "some comments"  

git ci --amend # 修改最后一次提交记录  

git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象  

git revert HEAD # 恢复最后一次提交的状态  
```

 

**查看提交记录**

```
git log git log <file> # 查看该文件每次提交记录  

git log -p <file> # 查看每次详细修改内容的diff  

git log -p -2 # 查看最近两次详细修改内容的diff  

git log --stat #查看提交统计信息  

tig

Mac上可以使用tig代替diff和log，brew install tig
```

 

**Git 本地分支管理**
**查看、切换、创建和删除分支**

```
git br -r # 查看远程分支  

git br <new_branch> # 创建新的分支  

git br -v # 查看各个分支最后提交信息  

git br --merged # 查看已经被合并到当前分支的分支  

git br --no-merged # 查看尚未被合并到当前分支的分支  

git co <branch> # 切换到某个分支  

git co -b <new_branch> # 创建新的分支，并且切换过去  

git co -b <new_branch> <branch> # 基于branch创建新的new_branch  

git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  

git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支  

git br -d <branch> # 删除某个分支  

git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  
```

 

**分支合并和reba**

```
git merge <branch> # 将branch分支合并到当前分支  

git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交  

git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch>  
```

 

**Git补丁管理(方便在多台机器上开发同步时用)**

```
git merge <branch> # 将branch分支合并到当前分支  

git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交  

git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch>  
```

 

**Git暂存管**

```
git stash # 暂存  

git stash list # 列所有stash  

git stash apply # 恢复暂存的内容  

git stash drop # 删除暂存区  
```

 

**Git远程分支管理**

```
git pull # 抓取远程仓库所有分支更新并合并到本地  

git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  

git fetch origin # 抓取远程仓库更新  

git merge origin/master # 将远程主分支合并到本地当前分支  

git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支  

git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上  
```

 

**git push # push所有分支**

```
git push origin master # 将本地主分支推到远程主分支  

git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  

git push origin <local_branch> # 创建远程分支， origin是远程仓库名  

git push origin <local_branch>:<remote_branch> # 创建远程分支  

git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  
```

 

**Git远程仓库管**

```
git remote -v # 查看远程服务器地址和仓库名称  

git remote show origin # 查看远程服务器仓库状态  

git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址  

git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库 
```

 

**创建远程仓库**

```
git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库  

scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上  

mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库  

git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址  

git push -u origin master # 客户端首次提交  

git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track  

git remote set-head origin master # 设置远程仓库的HEAD指向master分支 
```

**也可以命令设置跟踪远程库和本地库**

```
git branch --set-upstream master origin/master  

git branch --set-upstream develop origin/develop 
```

# python中 logging的使用详解

2020-12-13 00:24Wanna_Go [Python](http://www.zzvips.com/jiaoben/python/)

这篇文章主要介绍了python中 logging的使用，非常不错，具有参考借鉴价值,需要的朋友可以参考下

日志是用来记录程序在运行过程中发生的状况，在程序开发过程中添加日志模块能够帮助我们了解程序运行过程中发生了哪些事件，这些事件也有轻重之分。

**根据事件的轻重可分为以下几个级别：**

DEBUG： 详细信息，通常仅在诊断问题时才受到关注。整数level=10

INFO： 确认程序按预期工作。整数level=20

WARNING：出现了异常，但是不影响正常工作.整数level=30

ERROR：由于某些原因，程序 不能执行某些功能。整数level=40

CRITICAL：严重的错误，导致程序不能运行。整数level=50

默认的级别是WARNING,也就意味着只有级别大于等于的才会被看到，跟踪日志的方式可以是写入到文件中，也可以直接输出到控制台。

**输出到控制台**

下面是一个小例子通过将日志输出到控制台的方法：

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``logging.warning(``'Watch out!'``) ``# 将输出到控制台``logging.info(``'I told you so'``) ``# 不会输出``logging.error(``"an error occurrence！"``) ``#将输出到控制台
```

输出结果

[?](http://www.zzvips.com/article/122752.html#)

```
WARNING:root:Watch out!``ERROR:root:an error occurrence
```

**输出到文件中**

新开一个[python](http://www.zzvips.com/article/114962.html)解释器，确保不是上面代码的session

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``logging.basicConfig(filename``=``'example.log'``,level``=``logging.DEBUG)``logging.debug(``'This message should go to the log file'``)``logging.info(``'So should this'``)``logging.warning(``'And this, too'``)
```

这个时候控制台上面就没有了输出，文件example.log中的内容

[?](http://www.zzvips.com/article/122752.html#)

```
DEBUG:root:This message should go to the log ``file``INFO:root:So should this``WARNING:root:And this, too
```

假定需要手动调整日志的级别，我们可以在命令行以参数的形式传入--log=INFO,在代码中可以采用下面的处理方式

[?](http://www.zzvips.com/article/122752.html#)

```
# 输入参数 --log=DEBUG or --log=debug``numeric_level ``=` `getattr``(logging, loglevel.upper(), ``None``)``#返回10，否则None``if` `not` `isinstance``(numeric_level, ``int``):`` ``raise` `ValueError(``'Invalid log level: %s'` `%` `loglevel)``logging.basicConfig(level``=``numeric_level, ...)
```

**变量的日志**

[使用](http://www.zzvips.com/article/21177.html)格式化字符串的方式，为变量添加日志

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``logging.warning(``'%s before you %s'``, ``'Look'``, ``'leap!'``)
```

**自定义日志格式**

我们还可以根据我们的需求自定义输出模板

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``logging.basicConfig(``format``=``'%(asctime)s: %(levelname)s: %(message)s'``,level``=``logging.DEBUG)``logging.debug(``'This message should appear on the console'``)``logging.info(``'So should this'``)``logging.warning(``'And this, too'``)
```

输出

[?](http://www.zzvips.com/article/122752.html#)

```
2017``-``10``-``24` `14``:``03``:``53``,``671``: DEBUG: This message should appear on the console``2017``-``10``-``24` `14``:``03``:``53``,``690``: INFO: So should this``2017``-``10``-``24` `14``:``03``:``53``,``694``: WARNING: And this, too
```

内部实际传入的为一个字典，%(key)为字典的key。

上面是python logging模块的一些基本用法， 已经能够满足我们的许多需求，下面简单介绍下logging的一些高级用法。在logging模块中主要包括logger，handlers，filter，formatters，这几个组件

logger:提供了应用接口，供程序使用
handlers:用来将logger创建的log 发送到相应的目的地
filter:为要输出的日志提供了更细粒度的设置
formatters:设置最终的输出格式

下面是这几个组件配合使用的例子

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``logger ``=` `logging.getLogger(``'logger_name'``)``# 创建logger对象``logger.setLevel(logging.DEBUG)``handler ``=` `logging.StreamHandler()``# 创建 console handler 并设置级别为debug``handler.setLevel(logging.DEBUG)``formatter ``=` `logging.Formatter(``'%(asctime)s - %(name)s - %(levelname)s - %(message)s'``)``# 创建输出格式``handler.setFormatter(formatter)``# 为handler添加fromatter``logger.addHandler(handler)``# 将handler添加到 logger``logger.debug(``'debug message'``)``# 'application' code``logger.info(``'info message'``)``logger.warn(``'warn message'``)``logger.error(``'error message'``)``logger.critical(``'critical message'``)
```

输出结果：

2017-10-24 16:50:43,127 - logger_name - DEBUG - debug message
2017-10-24 16:50:43,138 - logger_name - INFO - info message
2017-10-24 16:50:43,141 - logger_name - WARNING - warn message
2017-10-24 16:50:43,144 - logger_name - ERROR - error message
2017-10-24 16:50:43,148 - logger_name - CRITICAL - critical message

**小应用案例**

下面是自己定义的一个日志处理方法，既能够写入到文件中（滚动保存近15天的日志，日志格式app.log, app.log.1, app.log.2），又能输出到控制台。

[?](http://www.zzvips.com/article/122752.html#)

```
import` `logging``from` `logging.handlers ``import` `TimedRotatingFileHandler``class` `MylogHandler(logging.Logger):`` ``def` `__init__(``self``,name,level``=``"DEBUG"``,stream``=``True``,files``=``True``):`` ``self``.name ``=` `name`` ``self``.level ``=` `level`` ``logging.Logger.__init__(``self``,``self``.name,level``=``self``.level)`` ``if` `stream:``  ``self``.__streamHandler__(``self``.level)`` ``if` `files:``  ``self``.__filesHandler__(``self``.level)`` ``def` `__streamHandler__(``self``,level``=``None``):`` ``handler ``=` `TimedRotatingFileHandler(filename``=``self``.name``+``".log"``, when``=``'D'``, interval``=``1``, backupCount``=``15``)`` ``handler.suffix ``=` `'%Y%m%d.log'`` ``handler.setLevel(level)`` ``formatter ``=` `logging.Formatter(``'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'``)`` ``handler.setFormatter(formatter)`` ``self``.addHandler(handler) ``#将hander添加到logger上`` ``def` `__filesHandler__(``self``,level``=``None``):`` ``handler ``=` `logging.StreamHandler()`` ``formatter ``=` `logging.Formatter(``'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'``)`` ``handler.setFormatter(formatter)`` ``handler.setLevel(level)`` ``self``.addHandler(handler)``if` `__name__ ``=``=` `'__main__'``:`` ``log ``=` `MylogHandler(``'test'``)`` ``log.info(``'this is a my log handler'``)
```

**总结**

以上所述是小编给大家介绍的python中 logging的使用详解，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对服务器之家网站的支持！

原文链接：http://www.cnblogs.com/wxshi/p/7724975.html?utm_source=tuicool&utm_medium=referral

# python 日志 logging模块(详细解析)

![img](https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png)

[天健胡马灵越鸟](https://blog.csdn.net/pansaky) 2019-05-31 09:51:08 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png) 50704 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png) 收藏 208

分类专栏： [python](https://blog.csdn.net/pansaky/category_8552001.html)

## 1 基本使用

```
转自：https://www.cnblogs.com/wf-linux/archive/2018/08/01/9400354.html
配置logging基本的设置，然后在控制台输出日志，
import logging



logging.basicConfig(level = logging.INFO,format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')



logger = logging.getLogger(__name__)



 



logger.info("Start print log")



logger.debug("Do something")



logger.warning("Something maybe fail.")



logger.info("Finish")
```

运行时，控制台输出，

```
2016-10-09 19:11:19,434 - __main__ - INFO - Start print log



2016-10-09 19:11:19,434 - __main__ - WARNING - Something maybe fail.



2016-10-09 19:11:19,434 - __main__ - INFO - Finish
logging中可以选择很多消息级别，如debug、info、warning、error以及critical。通过赋予logger或者handler不同的级别，开发者就可以只输出错误信息到特定的记录文件，或者在调试时只记录调试信息。
例如，我们将logger的级别改为DEBUG，再观察一下输出结果，
logging.basicConfig(level = logging.DEBUG,format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
控制台输出，可以发现，输出了debug的信息。
2016-10-09 19:12:08,289 - __main__ - INFO - Start print log



2016-10-09 19:12:08,289 - __main__ - DEBUG - Do something



2016-10-09 19:12:08,289 - __main__ - WARNING - Something maybe fail.



2016-10-09 19:12:08,289 - __main__ - INFO - Finish
logging.basicConfig函数各参数：
filename：指定日志文件名；
filemode：和file函数意义相同，指定日志文件的打开模式，'w'或者'a'；
format：指定输出的格式和内容，format可以输出很多有用的信息，
参数：作用



 



%(levelno)s：打印日志级别的数值



%(levelname)s：打印日志级别的名称



%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]



%(filename)s：打印当前执行程序名



%(funcName)s：打印日志的当前函数



%(lineno)d：打印日志的当前行号



%(asctime)s：打印日志的时间



%(thread)d：打印线程ID



%(threadName)s：打印线程名称



%(process)d：打印进程ID



%(message)s：打印日志信息
datefmt：指定时间格式，同time.strftime()；
level：设置日志级别，默认为logging.WARNNING；
stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略；
 
```

## 2 将日志写入到文件

```
2.2.1 将日志写入到文件
设置logging，创建一个FileHandler，并对输出消息的格式进行设置，将其添加到logger，然后将日志写入到指定的文件中，
import logging



logger = logging.getLogger(__name__)



logger.setLevel(level = logging.INFO)



handler = logging.FileHandler("log.txt")



handler.setLevel(logging.INFO)



formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')



handler.setFormatter(formatter)



logger.addHandler(handler)



 



logger.info("Start print log")



logger.debug("Do something")



logger.warning("Something maybe fail.")



logger.info("Finish")
```

log.txt中日志数据为，

```
2016-10-09 19:01:13,263 - __main__ - INFO - Start print log



2016-10-09 19:01:13,263 - __main__ - WARNING - Something maybe fail.



2016-10-09 19:01:13,263 - __main__ - INFO - Finish
2.2 将日志同时输出到屏幕和日志文件
logger中添加StreamHandler，可以将日志输出到屏幕上，
import logging



logger = logging.getLogger(__name__)



logger.setLevel(level = logging.INFO)



handler = logging.FileHandler("log.txt")



handler.setLevel(logging.INFO)



formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')



handler.setFormatter(formatter)



 



console = logging.StreamHandler()



console.setLevel(logging.INFO)



 



logger.addHandler(handler)



logger.addHandler(console)



 



logger.info("Start print log")



logger.debug("Do something")



logger.warning("Something maybe fail.")



logger.info("Finish")
```

可以在log.txt文件和控制台中看到，

```
2016-10-09 19:20:46,553 - __main__ - INFO - Start print log



2016-10-09 19:20:46,553 - __main__ - WARNING - Something maybe fail.



2016-10-09 19:20:46,553 - __main__ - INFO - Finish
可以发现，logging有一个日志处理的主对象，其他处理方式都是通过addHandler添加进去，logging中包含的handler主要有如下几种，
handler名称：位置；作用



 



StreamHandler：logging.StreamHandler；日志输出到流，可以是sys.stderr，sys.stdout或者文件



FileHandler：logging.FileHandler；日志输出到文件



BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式



RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚



TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件



SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets



DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets



SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址



SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog



NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志



MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer



HTTPHandler：logging.handlers.HTTPHandler；通过"GET"或者"POST"远程输出到HTTP服务器
2.3 日志回滚
使用RotatingFileHandler，可以实现日志回滚，
import logging



from logging.handlers import RotatingFileHandler



logger = logging.getLogger(__name__)



logger.setLevel(level = logging.INFO)



#定义一个RotatingFileHandler，最多备份3个日志文件，每个日志文件最大1K



rHandler = RotatingFileHandler("log.txt",maxBytes = 1*1024,backupCount = 3)



rHandler.setLevel(logging.INFO)



formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')



rHandler.setFormatter(formatter)



 



console = logging.StreamHandler()



console.setLevel(logging.INFO)



console.setFormatter(formatter)



 



logger.addHandler(rHandler)



logger.addHandler(console)



 



logger.info("Start print log")



logger.debug("Do something")



logger.warning("Something maybe fail.")



logger.info("Finish")
可以在工程目录中看到，备份的日志文件，
2016/10/09  19:36               732 log.txt



2016/10/09  19:36               967 log.txt.1



2016/10/09  19:36               985 log.txt.2



2016/10/09  19:36               976 log.txt.3
 
```

## 2.3 设置消息的等级

```
可以设置不同的日志等级，用于控制日志的输出，
日志等级：使用范围



 



FATAL：致命错误



CRITICAL：特别糟糕的事情，如内存耗尽、磁盘空间为空，一般很少使用



ERROR：发生错误时，如IO操作失败或者连接问题



WARNING：发生很重要的事件，但是并不是错误时，如用户登录密码错误



INFO：处理请求或者状态变化等日常事务



DEBUG：调试过程中使用DEBUG等级，如算法中每个循环的中间状态
 
```

## 2.4 捕获traceback

```
Python中的traceback模块被用于跟踪异常返回信息，可以在logging中记录下traceback，
代码，
import logging



logger = logging.getLogger(__name__)



logger.setLevel(level = logging.INFO)



handler = logging.FileHandler("log.txt")



handler.setLevel(logging.INFO)



formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')



handler.setFormatter(formatter)



 



console = logging.StreamHandler()



console.setLevel(logging.INFO)



 



logger.addHandler(handler)



logger.addHandler(console)



 



logger.info("Start print log")



logger.debug("Do something")



logger.warning("Something maybe fail.")



try:



    open("sklearn.txt","rb")



except (SystemExit,KeyboardInterrupt):



    raise



except Exception:



    logger.error("Faild to open sklearn.txt from logger.error",exc_info = True)



 



logger.info("Finish")
```

 

控制台和日志文件log.txt中输出，

```
Start print log



Something maybe fail.



Faild to open sklearn.txt from logger.error



Traceback (most recent call last):



  File "G:\zhb7627\Code\Eclipse WorkSpace\PythonTest\test.py", line 23, in <module>



    open("sklearn.txt","rb")



IOError: [Errno 2] No such file or directory: 'sklearn.txt'



Finish
也可以使用logger.exception(msg,_args)，它等价于logger.error(msg,exc_info = True,_args)，
将
logger.error("Faild to open sklearn.txt from logger.error",exc_info = True)
替换为，
logger.exception("Failed to open sklearn.txt from logger.exception")
控制台和日志文件log.txt中输出，
Start print log



Something maybe fail.



Failed to open sklearn.txt from logger.exception



Traceback (most recent call last):



  File "G:\zhb7627\Code\Eclipse WorkSpace\PythonTest\test.py", line 23, in <module>



    open("sklearn.txt","rb")



IOError: [Errno 2] No such file or directory: 'sklearn.txt'



Finish
 
```

## 2.5 多模块使用logging

```
主模块mainModule.py，
import logging



import subModule



logger = logging.getLogger("mainModule")



logger.setLevel(level = logging.INFO)



handler = logging.FileHandler("log.txt")



handler.setLevel(logging.INFO)



formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')



handler.setFormatter(formatter)



 



console = logging.StreamHandler()



console.setLevel(logging.INFO)



console.setFormatter(formatter)



 



logger.addHandler(handler)



logger.addHandler(console)



 



 



logger.info("creating an instance of subModule.subModuleClass")



a = subModule.SubModuleClass()



logger.info("calling subModule.subModuleClass.doSomething")



a.doSomething()



logger.info("done with  subModule.subModuleClass.doSomething")



logger.info("calling subModule.some_function")



subModule.som_function()



logger.info("done with subModule.some_function")
```

子模块subModule.py，

```python
import logging



 



module_logger = logging.getLogger("mainModule.sub")



class SubModuleClass(object):



    def __init__(self):



        self.logger = logging.getLogger("mainModule.sub.module")



        self.logger.info("creating an instance in SubModuleClass")



    def doSomething(self):



        self.logger.info("do something in SubModule")



        a = []



        a.append(1)



        self.logger.debug("list a = " + str(a))



        self.logger.info("finish something in SubModuleClass")



 



def som_function():



    module_logger.info("call function some_function")
```

执行之后，在控制和日志文件log.txt中输出，

```
2016-10-09 20:25:42,276 - mainModule - INFO - creating an instance of subModule.subModuleClass



2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - creating an instance in SubModuleClass



2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.subModuleClass.doSomething



2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - do something in SubModule



2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - finish something in SubModuleClass



2016-10-09 20:25:42,279 - mainModule - INFO - done with  subModule.subModuleClass.doSomething



2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.some_function



2016-10-09 20:25:42,279 - mainModule.sub - INFO - call function some_function



2016-10-09 20:25:42,279 - mainModule - INFO - done with subModule.some_function
首先在主模块定义了logger'mainModule'，并对它进行了配置，就可以在解释器进程里面的其他地方通过getLogger('mainModule')得到的对象都是一样的，不需要重新配置，可以直接使用。定义的该logger的子logger，都可以共享父logger的定义和配置，所谓的父子logger是通过命名来识别，任意以'mainModule'开头的logger都是它的子logger，例如'mainModule.sub'。
实际开发一个application，首先可以通过logging配置文件编写好这个application所对应的配置，可以生成一个根logger，如'PythonAPP'，然后在主函数中通过fileConfig加载logging配置，接着在application的其他地方、不同的模块中，可以使用根logger的子logger，如'PythonAPP.Core'，'PythonAPP.Web'来进行log，而不需要反复的定义和配置各个模块的logger。
```

# 3 通过JSON或者YAML文件配置logging模块

```
尽管可以在Python代码中配置logging，但是这样并不够灵活，最好的方法是使用一个配置文件来配置。在Python 2.7及以后的版本中，可以从字典中加载logging配置，也就意味着可以通过JSON或者YAML文件加载日志的配置。
```

## 3.1 通过JSON文件配置

```
JSON配置文件，
{



    "version":1,



    "disable_existing_loggers":false,



    "formatters":{



        "simple":{



            "format":"%(asctime)s - %(name)s - %(levelname)s - %(message)s"



        }



    },



    "handlers":{



        "console":{



            "class":"logging.StreamHandler",



            "level":"DEBUG",



            "formatter":"simple",



            "stream":"ext://sys.stdout"



        },



        "info_file_handler":{



            "class":"logging.handlers.RotatingFileHandler",



            "level":"INFO",



            "formatter":"simple",



            "filename":"info.log",



            "maxBytes":"10485760",



            "backupCount":20,



            "encoding":"utf8"



        },



        "error_file_handler":{



            "class":"logging.handlers.RotatingFileHandler",



            "level":"ERROR",



            "formatter":"simple",



            "filename":"errors.log",



            "maxBytes":10485760,



            "backupCount":20,



            "encoding":"utf8"



        }



    },



    "loggers":{



        "my_module":{



            "level":"ERROR",



            "handlers":["info_file_handler"],



            "propagate":"no"



        }



    },



    "root":{



        "level":"INFO",



        "handlers":["console","info_file_handler","error_file_handler"]



    }



}
通过JSON加载配置文件，然后通过logging.dictConfig配置logging，
 
import json



import logging.config



import os



 



def setup_logging(default_path = "logging.json",default_level = logging.INFO,env_key = "LOG_CFG"):



    path = default_path



    value = os.getenv(env_key,None)



    if value:



        path = value



    if os.path.exists(path):



        with open(path,"r") as f:



            config = json.load(f)



            logging.config.dictConfig(config)



    else:



        logging.basicConfig(level = default_level)



 



def func():



    logging.info("start func")



 



    logging.info("exec func")



 



    logging.info("end func")



 



if __name__ == "__main__":



    setup_logging(default_path = "logging.json")



    func()
```

 

## 3.2 通过YAML文件配置

```
通过YAML文件进行配置，比JSON看起来更加简介明了，
version: 1



disable_existing_loggers: False



formatters:



        simple:



            format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"



handlers:



    console:



            class: logging.StreamHandler



            level: DEBUG



            formatter: simple



            stream: ext://sys.stdout



    info_file_handler:



            class: logging.handlers.RotatingFileHandler



            level: INFO



            formatter: simple



            filename: info.log



            maxBytes: 10485760



            backupCount: 20



            encoding: utf8



    error_file_handler:



            class: logging.handlers.RotatingFileHandler



            level: ERROR



            formatter: simple



            filename: errors.log



            maxBytes: 10485760



            backupCount: 20



            encoding: utf8



loggers:



    my_module:



            level: ERROR



            handlers: [info_file_handler]



            propagate: no



root:



    level: INFO



    handlers: [console,info_file_handler,error_file_handler]
通过YAML加载配置文件，然后通过logging.dictConfig配置logging，
import yaml



import logging.config



import os



 



def setup_logging(default_path = "logging.yaml",default_level = logging.INFO,env_key = "LOG_CFG"):



    path = default_path



    value = os.getenv(env_key,None)



    if value:



        path = value



    if os.path.exists(path):



        with open(path,"r") as f:



            config = yaml.load(f)



            logging.config.dictConfig(config)



    else:



        logging.basicConfig(level = default_level)



 



def func():



    logging.info("start func")



 



    logging.info("exec func")



 



    logging.info("end func")



 



if __name__ == "__main__":



    setup_logging(default_path = "logging.yaml")



    func()
```

 