# 正则表达式study1

\d代表任意数字，就是阿拉伯数字 0-9 这些玩意。

`\D`大写的就是和小写的唱反调，\d 你代表的是任意数字是吧？那么我 \D 就代表不是数字的。

`\w`代表字母，数字，下划线。也就是 a-z、A-Z、0-9、_。

\W跟 \w 唱反调，代表不是字母，不是数字，不是下划线的。

\n代表一个换行。

`\r`代表一个回车。

`\f`代表换页。

`\t`代表一个 Tab 。

\s代表所有的空白字符，也就是上面这个：\n、\r、\t、\f。`

\S跟 \s 唱反调，代表所有不是空白的字符。

`\A`代表字符串的开始。

`\Z`代表字符串的结束。

^匹配字符串开始的位置。

$匹配字符创结束的位置。

.代表所有的单个字符，除了 \n \r

`[...]`代表在 [] 范围内的字符，比如 [a-z] 就代表 a到z的字母`[^...]`跟 [...] 唱反调，代表不在 [] 范围内的字符

{n}匹配在 {n} 前面的东西，比如: o{2} 不能匹配 Bob 中的 o ，但是能匹配 food 中的两个o。

`{n,m}`匹配在 {n,m} 前面的东西，比如：o{1,3} 将匹配“fooooood”中的前三个o。

`{n，}`匹配在 {n,} 前面的东西，比如：o{2,} 不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。

`*`和 {0,} 一个样，匹配 * 前面的 0 次或多次。 比如 zo* 能匹配“z”、“zo”以及“zoo”。

`+`和{1，} 一个样，匹配 + 前面 1 次或多次。 比如 zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。

`？`和{0,1} 一个样，匹配 ？前面 0 次或 1 次。

ok



知道了这些之后



我们怎么用 python 来进行判断呢？



那就要使用到 python 的库了



它就是



**re**



接下来我们就来使用 re 模块



对其常用的方法



来使用正则表达式



**re.match**



使用这个方法



主要传入两个参数



第一个就是我们的匹配规则



第二个就是需要被过滤的内容



例如



我们想要从这



```text
Xiaoshuaib has 100 bananas
```



拿到一个数字



那么我们就可以这样



```text
import re

content = 'Xiaoshuaib has 100 bananas'
res = re.match('^Xi.*(\d+)\s.*s$',content)
print(res.group(1))
```



通过我们刚刚说的匹配符号



可以定义出相应的匹配规则



在这里我们将我们需要的目标内容用 () 括起来



此刻我们获得结果是



0



那么如果我们想要 100 这个数字呢？



可以这样



```text
import re

content = 'Xiaoshuaib has 100 bananas'
res = re.match('^Xi.*?(\d+)\s.*s$',content)
print(res.group(1))
```



看出区别了么



第二段代码我们多了一个 ？符号



在这里呢



涉及到两个概念



一个是



贪婪匹配



另一个是



非贪婪匹配



所谓贪婪匹配



就是我们的第一段代码



一个数一个数都要去匹配



而非贪婪呢



我们是直接把 100 给匹配出来了





![img](https://pic2.zhimg.com/80/v2-ab346284f8e27891874ef4b284be3585_720w.jpg)







刚刚我们用到的



**.\*？**



是我们在匹配过程中最常使用到的



表示的就是匹配任意字符



但是



.*？的 . 代表所有的单个字符，除了 \n \r



如果我们的字符串有换行了



怎么办呢？



比如这样



```text
content = """Xiaoshuaib has 100 
bananas"""
```



那么我们就需要用到 re 的匹配模式了



说来也简单



直接用 re.S 就可以了



```text
import re

content = """Xiaoshuaib has 100 
bananas"""
res = re.match('^Xi.*?(\d+)\s.*s$',content,re.S)
print(res.group(1))
```



可能有些朋友会觉得



匹配一个东西还要写开头结尾



有点麻烦



那么就可以使用 re 的另一个方法了





**re.search**





它会直接去扫描字符串



然后把匹配成功的**第一个**结果的返回给你



```text
import re

content = """Xiaoshuaib has 100 
bananas"""
res = re.search('Xi.*?(\d+)\s.*s',content,re.S)
print(res.group(1))
```



这样子也是可以获取 100 的



但是如果我们的内容是这样的



```text
content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
```



想要获取**所有**的 100 呢？



这时候就要用到 re 的另一个方法了





**re.findall**



通过它我们就能轻松的获取所有匹配的内容了



```text
import re

content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
res = re.findall('Xi.*?(\d+)\s.*?s;',content,re.S)
print(res)
```



这里的结果是



['100', '100', '100', '100']





![img](https://pic1.zhimg.com/80/v2-cafece2e64b19ed0282c30a68c9efda4_720w.jpg)





又有朋友觉得



如果我们想直接替换匹配的内容呢



就比如刚刚的字符串



可不可以把 100 直接替换成 250 呢？





![img](https://pic1.zhimg.com/80/v2-295e2d1f5ddc7699e00a0a38f9fe3b00_720w.jpg)





那就要用到 re 的另一个方法了





**re.sub**





可以这样



```text
import re

content = """Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;
Xiaoshuaib has 100 bananas;"""
content = re.sub('\d+','250',content)
print(content)
```



那么结果就变成了



Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;

Xiaoshuaib has 250 bananas;



250 个香蕉



吃....得完么？？





![img](https://pic3.zhimg.com/80/v2-8d467b1adcbfdff35013bd6244f160c2_720w.jpg)







再来说说 re 的另一个常用到的方法吧





**re.compile**





这个主要就是把我们的匹配符封装一下



```text
import re

content = "Xiaoshuaib has 100 bananas"
pattern = re.compile('Xi.*?(\d+)\s.*s',re.S)
res = re.match(pattern,content)

print(res.group(1))
```





其实和我们之前写的一样的



```text
res = re.match('^Xi.*?(\d+)\s.*s$',content,re.S)
```



只不过 compile 一下



便于以后复用



好了



关于 re 模块和正则表达式就介绍完啦





知道了怎么请求数据



也知道了将返回的数据如何正则过滤



那么



爬虫对我们来说还难么？





![img](https://pic2.zhimg.com/80/v2-29519e82c5c4daeadbe7dc6f814d1121_720w.jpg)





这次本篇真的完啦

# 正则表达式study2

这一篇就够了！

[![慕课网](https://pic3.zhimg.com/v2-1a7e8b36a7dc94b127c6cea1773ed171_xs.jpg)](https://www.zhihu.com/org/mu-ke-wang-14)

[慕课网](https://www.zhihu.com/org/mu-ke-wang-14)[](https://www.zhihu.com/question/48510028)

已认证的官方帐号

394 人赞同了该文章

之前我们讲解了 [正则表达式语法](https://link.zhihu.com/?target=https%3A//www.imooc.com/article/300848) 的起源、发展、流派、语法、引擎、优化等相关知识，今天我们主要来学习一下 **正则表达式在 Python语言 中的应用**！

大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。

![img](https://pic4.zhimg.com/80/v2-389b0da89802d2111ba61e78b564f03f_720w.jpg)


re模块主要定义了9个常量、12个函数、1个异常，每个常量和函数猪哥都会通过实际代码案例讲解，让大家能更直观的了解其作用！

注：为避免出现代码格式错乱，猪哥尽量使用代码截图演示哦。

一、re模块简介

聊到Python正则表达式的支持，首先肯定会想到`re`库，这是一个Python处理文本的**标准库**。

**标准库**的意思表示这是一个**Python内置模块**，不需要额外下载，目前Python内置模块大概有300个。可以在这里查看Python所有的内置模块：[https://docs.python.org/3/py-modindex.html#cap-r](https://link.zhihu.com/?target=https%3A//docs.python.org/3/py-modindex.html%23cap-r)

因为re是内置模块，所以不需要再下载，使用时直接引入即可：

import re

re模块官方文档：[https://docs.python.org/zh-cn/3.8/library/re.html](https://link.zhihu.com/?target=https%3A//docs.python.org/zh-cn/3.8/library/re.html)
re模块库源码：[https://github.com/python/cpython/blob/3.8/Lib/re.py](https://link.zhihu.com/?target=https%3A//github.com/python/cpython/blob/3.8/Lib/re.py)

二、re模块常量

常量即表示不可更改的变量，一般用于做标记。

re模块中有9个常量，常量的值都是int类型！

![img](https://pic4.zhimg.com/80/v2-192d31a9de5470456c61e96d9a9d1aab_720w.jpg)


上图我们可以看到，所有的常量都是在**RegexFlag枚举类**来实现，这是在Python 3.6做的改版。在Python 3.6以前版本是直接将常量写在re.py中，使用枚举的好处就是方便管理和使用！

![img](https://pic2.zhimg.com/80/v2-d442174c6eb02902f5d3e209b9939dc1_720w.jpg)



下面我们来快速学习这些常量的作用及如何使用他们，按常用度排序！

\1. IGNORECASE

**语法：** re.IGNORECASE 或简写为 re.I

**作用：** 进行忽略大小写匹配。

**代码案例：**

![img](https://pic1.zhimg.com/80/v2-6f44888e6114a98b2202a92a8adb7d5c_720w.jpg)


在默认匹配模式下**大写字母B**无法匹配**小写字母b**，而在 忽略大小写 模式下是可以的。

\2. ASCII

**语法：** re.ASCII 或简写为 re.A

**作用：** 顾名思义，ASCII表示ASCII码的意思，让 `\w`, `\W`, `\b`, `\B`, `\d`, `\D`, `\s` 和 `\S` 只匹配ASCII，而不是Unicode。

**代码案例：**

![img](https://pic3.zhimg.com/80/v2-1a6b313162711f831dc781303e32f172_720w.jpg)


在默认匹配模式下`\w+`匹配到了所有字符串，而在**ASCII**模式下，只匹配到了a、b、c（ASCII编码支持的字符）。

注意：这只对字符串匹配模式有效，对字节匹配模式无效。

\3. DOTALL

**语法：** re.DOTALL 或简写为 re.S

**作用：** DOT表示`.`，ALL表示所有，连起来就是`.`匹配所有，包括换行符`\n`。**默认模式下`.`是不能匹配行符`\n`的**。

**代码案例：**

![img](https://pic4.zhimg.com/80/v2-b4ba1028a21217a29497952101c8947b_720w.jpg)


在默认匹配模式下`.`并没有匹配换行符`\n`，而是将字符串分开匹配；而在**re.DOTALL**模式下，换行符`\n`与字符串一起被匹配到。

注意：**默认匹配模式下`.`并不会匹配换行符`\n`**。

\4. MULTILINE

**语法：** re.MULTILINE 或简写为 re.M

**作用：** 多行模式，当某字符串中有换行符`\n`，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。

**代码案例：**

![img](https://pic4.zhimg.com/80/v2-67991439abbbb34c38b239af08793bbf_720w.jpg)


正则表达式中`^`表示匹配行的开头，默认模式下它只能匹配字符串的开头；而在多行模式下，它还可以匹配 换行符`\n`后面的字符。

注意：正则语法中`^`匹配行开头、`\A`匹配字符串开头，单行模式下它两效果一致，多行模式下`\A`不能识别`\n`。

\5. VERBOSE

**语法：** re.VERBOSE 或简写为 re.X

**作用：** 详细模式，可以在正则表达式中加注解！

**代码案例：**

![img](https://pic1.zhimg.com/80/v2-cfe888f6f0db818d416e343ff51beb08_720w.jpg)


默认模式下并不能识别正则表达式中的注释，而详细模式是可以识别的。

当一个正则表达式十分复杂的时候，详细模式或许能为你提供另一种注释方式，但它不应该成为炫技的手段，建议谨慎考虑后使用！

6.LOCALE

**语法：** re.LOCALE 或简写为 re.L

**作用：** 由当前语言区域决定 `\w`, `\W`, `\b`, `\B` 和大小写敏感匹配，这个标记只能对byte样式有效。**这个标记官方已经不推荐使用**，因为语言区域机制很不可靠，它一次只能处理一个 "习惯”，而且只对8位字节有效。

**注意：** 由于这个标记官方已经不推荐使用，而且猪哥也没使用过，所以就不给出实际的案例！

7.UNICODE

**语法：** re.UNICODE 或简写为 re.U

**作用：** 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。

\8. DEBUG

**语法：** re.DEBUG

**作用：** 显示编译时的debug信息。

**代码案例：**

![img](https://pic2.zhimg.com/80/v2-b4eeb795e2a9480935d4fe5233632615_720w.jpg)



虽然debug模式下确实会打印编译信息，但猪哥并不理解这是什么语言 以及表达的含义，**希望了解的朋友能不吝赐教。**

9.TEMPLATE

**语法：** re.TEMPLATE 或简写为 re.T

**作用：** 猪哥也没搞懂TEMPLATE的具体用处，源码注释中写着：disable backtracking(禁用回溯)，有了解的同学可以留言告知！

![img](https://pic3.zhimg.com/80/v2-2177dfe09c9b6d797a1882c322e976c2_720w.jpg)



\10. 常量总结



1. 9个常量中，前5个（IGNORECASE、ASCII、DOTALL、MULTILINE、VERBOSE）有用处，两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。
2. 常量在re常用函数中都可以使用，查看源码可得知。

![img](https://pic3.zhimg.com/80/v2-0eb3458cd7289709bb70add59efcd962_720w.jpg)



1. 常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 `|` 符号，请勿使用`+` 符号！

![img](https://pic3.zhimg.com/80/v2-6656131dde9861872b16e4cf6be1c43e_720w.jpg)





最后来一张思维导图总结一下re模块中的常量吧，**需要高清图或者xmind文件的同学可在「裸睡的猪」后台回复：re** 获取。

![img](https://pic4.zhimg.com/80/v2-8739802053ac450de80b35f6bcf90acb_720w.jpg)



三、re模块函数

re模块有12个函数，猪哥将以功能分类来讲解；这样更具有比较性，同时也方便记忆。

1.查找一个匹配项

查找并返回一个匹配项的函数有3个：**search、match、fullmatch**，他们的区别分别是：



1. **search：** 查找任意位置的匹配项
2. **match：** 必须从字符串开头匹配
3. **fullmatch：** 整个字符串与正则完全匹配



我们再来根据实际的代码案例比较：

**案例1:**

![img](https://pic1.zhimg.com/80/v2-df4c23c93f5ca9ffe242f4a60a44ee1c_720w.jpg)


案例1中**search函数**是在字符串中任意位置匹配，只要有符合正则表达式的字符串就匹配成功，其实有两个匹配项，但search函数值返回一个。

而**match函数**是要从头开始匹配，而字符串开头多了个字母`a`，所以无法匹配，**fullmatch函数**需要完全相同，故也不匹配！

**案例2:**

![img](https://pic4.zhimg.com/80/v2-3394c33c6ad529715f67e9171f5f1bef_720w.jpg)


案例2删除了text最开头的字母a，这样**match函数**就可以匹配啦，而**fullmatch函数**依然不能完全匹配！

**案例3:**

![img](https://pic1.zhimg.com/80/v2-c5e5ffe0b2c59d20a5dd45c317ecac9c_720w.jpg)


案例3中，我们只留下一段文字，并且与正则表达式一致；这时**fullmatch函数**终于可以匹配了。

**完整案例：**

![img](https://pic1.zhimg.com/80/v2-c2b0edb78cc7f3042c429841ced987bc_720w.jpg)


**注意：查找 一个匹配项 返回的都是一个匹配对象（Match）。**

2.查找多个匹配项

讲完查找一项，现在来看看查找多项吧，查找多项函数主要有：**findall函数** 与 **finditer函数**：



1. **findall：** 从字符串任意位置查找，**返回一个列表**
2. **finditer**：从字符串任意位置查找，**返回一个迭代器**



两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。



![img](https://pic1.zhimg.com/80/v2-4c2d71ce1088c2637266ab35a50c86c4_720w.jpg)


如果可能存在大量的匹配项的话，建议使用**finditer函数**，一般情况使用**findall函数**基本没啥影响。

3.分割

**re.split(pattern, string, maxsplit=0, flags=0)** 函数：用 **pattern** 分开 string ， **maxsplit**表示最多进行分割次数， **flags**表示模式，就是上面我们讲解的常量！



![img](https://pic4.zhimg.com/80/v2-c08fa8e4a6a445a37e36761ea0a79d27_720w.jpg)


**注意：`str`模块也有一个 split函数 ，那这两个函数该怎么选呢？**
str.split函数功能简单，不支持正则分割，而re.split支持正则。

**关于二者的速度如何？** 猪哥实际测试一下，在相同数据量的情况下使用`re.split`函数与`str.split`函数**执行次数** 与 **执行时间** 对比图：

![img](https://pic4.zhimg.com/80/v2-a0dfb7664a05c07f7b81d12702b0c52f_720w.jpg)


通过上图对比发现，1000次循环以内`str.split`函数更快，而循环次数1000次以上后`re.split`函数明显更快，而且次数越多差距越大！

**所以结论是：在 不需要正则支持 且 数据量和数次不多 的情况下使用`str.split`函数更合适，反之则使用`re.split`函数。**

注：具体执行时间与测试数据有关！

4.替换

替换主要有**sub函数** 与 **subn函数**，他们功能类似！

先来看看**sub函数**的用法：

**re.sub(pattern, repl, string, count=0, flags=0)** 函数参数讲解：repl替换掉string中被pattern匹配的字符， count表示最大替换次数，flags表示正则表达式的常量。

值得注意的是：**sub函数**中的入参：**repl替换内容既可以是字符串，也可以是一个函数哦！** 如果repl为函数时，只能有一个入参：Match匹配对象。



![img](https://pic4.zhimg.com/80/v2-acb374226ed45d39a4a7ba1e0d50712f_720w.jpg)



**re.subn(pattern, repl, string, count=0, flags=0)** 函数与 **re.sub函数** 功能一致，只不过返回一个元组 (字符串, 替换次数)。

![img](https://pic3.zhimg.com/80/v2-b057eee5f88e4427c78df37d74501bc2_720w.jpg)



5.编译正则对象

**compile函数** 与 **template函数** 将正则表达式的样式编译为一个 正则表达式对象 （正则对象Pattern），这个对象与re模块有同样的正则函数（后面我们会讲解Pattern正则对象）。

![img](https://pic4.zhimg.com/80/v2-ef6e89e8b83012863bca4b4a200bc7fb_720w.jpg)


而**template函数** 与 **compile函数** 类似，只不过是增加了我们之前说的**re.TEMPLATE** 模式，我们可以看看源码。

![img](https://pic4.zhimg.com/80/v2-b05daad758fc2a39ab3b87004d022887_720w.jpg)



6.其他

**re.escape(pattern)** 可以转义正则表达式中具有特殊含义的字符，比如：`.` 或者 `*` ，举个实际的案例：

![img](https://pic1.zhimg.com/80/v2-903a19ca6560faa5ff97e09b16e59390_720w.jpg)


**re.escape(pattern)** 看似非常好用省去了我们自己加转义，但是使用它很容易出现转义错误的问题，所以并不建议使用它转义，**而建议大家自己手动转义！**

**re.purge()** 函数作用就是清除 **正则表达式缓存**，具体有什么缓存呢？我们来看看源码就知道它背地里干了 什么：

![img](https://pic1.zhimg.com/80/v2-17371b6785ee8112fdfdfab08826c694_720w.jpg)


看方法大概是清除缓存吧，我们再来看看具体的案例：

![img](https://pic1.zhimg.com/80/v2-faa3ba56f8137d908f269b044248cf00_720w.jpg)


猪哥在两个案例之间使用了**re.purge()** 函数清除缓存，然后分别比较前后案例源码里面的缓存，看看是否有变化！

![img](https://pic3.zhimg.com/80/v2-161cac2bd5c2f5f2e42f7759b2cae632_720w.jpg)



7.总结

同样最后来一张思维导图总结一下re模块中的函数吧，**需要高清图或者xmind文件的同学可在微信公众号「裸睡的猪」后台回复：re** 获取。

![img](https://pic3.zhimg.com/80/v2-c022af882c868bde000896bc3271f6e6_720w.jpg)



四、re模块异常

re模块还包含了一个正则表达式的编译错误，当我们给出的**正则表达式是一个无效的表达式**（就是表达式本身有问题）时，就会raise一个异常！

我们来看看具体的案例吧：

![img](https://pic2.zhimg.com/80/v2-857ad9feebc68f088f573af472569155_720w.jpg)


上图案例中我们可以看到，在编写正则表达式中我们多写了一个括号，这导致执行结果报错；而且是在其他所有案例执行之前，所以说明是在正则表达式编译时期就报错了。

注意：这个异常一定是 正则表达式 本身是无效的，与要匹配的字符串无关！

五、正则对象Pattern

关于`re`模块的常量、函数、异常我们都讲解完毕，但是完全有必要再讲讲**正则对象Pattern**。

\1. 与re模块 函数一致

在`re`模块的函数中有一个重要的函数 **compile函数** ，这个函数可以预编译返回一个正则对象，此正则对象拥有与`re`模块相同的函数，我们来看看**Pattern类**的源码。

![img](https://pic1.zhimg.com/80/v2-6ae609e027806c511f578a24d623412c_720w.jpg)


既然是一致的，那到底该用**re模块** 还是 **正则对象Pattern** ？

而且，有些同学可能看过`re`模块的源码，你会发现其实**compile函数** 与 其他 **re函数**（search、split、sub等等） 内部调用的是同一个函数，最终还是调用正则对象的函数！

![img](https://pic1.zhimg.com/80/v2-793ac58ceff4191cb328869cb2a69ca4_720w.jpg)


也就是说下面 两种代码写法 底层实现 其实是一致的：

\# re函数 re.search(pattern, text) # 正则对象函数 compile = re.compile(pattern) compile.search(text)

那还有必要使用**compile函数** 得到正则对象再去调用 **search函数** 吗？直接调用re.search 是不是就可以？

\2. 官方文档怎么说

关于到底该用**re模块** 还是 **正则对象Pattern** ，官方文档是否有说明呢？



![img](https://pic1.zhimg.com/80/v2-5ba334ea73634a5d608c36ce752a5cf4_720w.jpg)


官方文档推荐：**在多次使用某个正则表达式时推荐使用正则对象Pattern** 以增加复用性，因为通过 **re.compile(pattern)** 编译后的模块级函数会被缓存！

\3. 实际测试又如何？

上面官方文档推荐我们在 **多次使用某个正则表达式时使用正则对象**，那实际情况真的是这样的吗？

我们在实测一下吧



![img](https://pic2.zhimg.com/80/v2-ed971d8cf18adf225f558bf45371ff45_720w.jpg)


猪哥编写了两个函数，一个使用**re.search函数** 另一个使用 **compile.search函数** ，分别(不同时)循环执行**count次**(count从1-1万)，比较两者的耗时！

得出的结果猪哥绘制成折线图：

![img](https://pic1.zhimg.com/80/v2-53f9618228c6509bd5235e939c2c523c_720w.jpg)


得出的结论是：100次循环以内两者的速度基本一致，当超出100次后，使用 **正则对象Pattern** 的函数 耗时明显更短，所以比**re模块** 要快！

通过实际测试得知：Python 官方文档推荐 **多次使用某个正则表达式时使用正则对象函数** 基本属实！

六、注意事项

Python 正则表达式知识基本讲解完毕，最后稍微给大家提一提需要注意的点。

1.字节串 与 字符串

模式和被搜索的字符串既可以是 Unicode 字符串 (str) ，也可以是8位字节串 (bytes)。 但是，Unicode 字符串与8位字节串不能混用！

2.r 的作用

正则表达式使用反斜杠（’’）来表示特殊形式，或者把特殊字符转义成普通字符。

而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。

解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 ‘r’ 前缀的字符串字面值中，反斜杠不必做任何特殊处理。

3.正则查找函数 返回匹配对象

查找一个匹配项（search、match、fullmatch）的函数返回值都是一个 **匹配对象Match** ，需要通过**match.group()** 获取匹配值，这个很容易忘记。

![img](https://pic4.zhimg.com/80/v2-5c3e53c27fcd5f643edd80d29410519f_720w.jpg)


另外还需要注意：**match.group()** 与**match.groups()** 函数的差别！

4.重复使用某个正则

如果要重复使用某个正则表达式，推荐先使用 **re.compile(pattern)函数** 返回一个正则对象，然后复用这个正则对象，这样会更快！

5.Python 正则面试

笔试可能会遇到需要使用Python正则表达式，不过不会太难的，大家只要记住那几个方法的区别，会正确使用，基本问题不大。

# Git命令大全

（查看、添加、提交、删除、找回，重置修改文件）

```
git help <command> # 显示command的help  

git show # 显示某次提交的内容 git show $id  

git co -- <file> # 抛弃工作区修改  

git co . # 抛弃工作区修改  

git add <file> # 将工作文件修改提交到本地暂存区  

git add . # 将所有修改过的工作文件提交暂存区  

git rm <file> # 从版本库中删除文件  

git rm <file> --cached # 从版本库中删除文件，但不删除文件  

git reset <file> # 从暂存区恢复到工作文件  

git reset -- . # 从暂存区恢复到工作文件  

git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  

git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am "some comments"  

git ci --amend # 修改最后一次提交记录  

git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象  

git revert HEAD # 恢复最后一次提交的状态  
```

 

**查看文件diff**

```
git help <command> # 显示command的help  

git show # 显示某次提交的内容 git show $id  

git co -- <file> # 抛弃工作区修改  

git co . # 抛弃工作区修改  

git add <file> # 将工作文件修改提交到本地暂存区  

git add . # 将所有修改过的工作文件提交暂存区  

git rm <file> # 从版本库中删除文件  

git rm <file> --cached # 从版本库中删除文件，但不删除文件  

git reset <file> # 从暂存区恢复到工作文件  

git reset -- . # 从暂存区恢复到工作文件  

git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  

git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am "some comments"  

git ci --amend # 修改最后一次提交记录  

git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象  

git revert HEAD # 恢复最后一次提交的状态  
```

 

**查看提交记录**

```
git log git log <file> # 查看该文件每次提交记录  

git log -p <file> # 查看每次详细修改内容的diff  

git log -p -2 # 查看最近两次详细修改内容的diff  

git log --stat #查看提交统计信息  

tig

Mac上可以使用tig代替diff和log，brew install tig
```

 

**Git 本地分支管理**
**查看、切换、创建和删除分支**

```
git br -r # 查看远程分支  

git br <new_branch> # 创建新的分支  

git br -v # 查看各个分支最后提交信息  

git br --merged # 查看已经被合并到当前分支的分支  

git br --no-merged # 查看尚未被合并到当前分支的分支  

git co <branch> # 切换到某个分支  

git co -b <new_branch> # 创建新的分支，并且切换过去  

git co -b <new_branch> <branch> # 基于branch创建新的new_branch  

git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  

git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支  

git br -d <branch> # 删除某个分支  

git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  
```

 

**分支合并和reba**

```
git merge <branch> # 将branch分支合并到当前分支  

git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交  

git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch>  
```

 

**Git补丁管理(方便在多台机器上开发同步时用)**

```
git merge <branch> # 将branch分支合并到当前分支  

git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交  

git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch>  
```

 

**Git暂存管**

```
git stash # 暂存  

git stash list # 列所有stash  

git stash apply # 恢复暂存的内容  

git stash drop # 删除暂存区  
```

 

**Git远程分支管理**

```
git pull # 抓取远程仓库所有分支更新并合并到本地  

git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  

git fetch origin # 抓取远程仓库更新  

git merge origin/master # 将远程主分支合并到本地当前分支  

git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支  

git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上  
```

 

**git push # push所有分支**

```
git push origin master # 将本地主分支推到远程主分支  

git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  

git push origin <local_branch> # 创建远程分支， origin是远程仓库名  

git push origin <local_branch>:<remote_branch> # 创建远程分支  

git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  
```

 

**Git远程仓库管**

```
git remote -v # 查看远程服务器地址和仓库名称  

git remote show origin # 查看远程服务器仓库状态  

git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址  

git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库 
```

 

**创建远程仓库**

```
git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库  

scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上  

mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库  

git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址  

git push -u origin master # 客户端首次提交  

git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track  

git remote set-head origin master # 设置远程仓库的HEAD指向master分支 
```

**也可以命令设置跟踪远程库和本地库**

```
git branch --set-upstream master origin/master  

git branch --set-upstream develop origin/develop 
```

